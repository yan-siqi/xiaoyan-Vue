# day01vue

### git 的版本控制

- 1). 创建本地仓库(代码在本地仓库中)
创建.gitignore文本, 并配置好
git init
git add .
git commit -m "init app"

- 2). 创建远程仓库
New Repo
指定仓库名
创建

- 3). 将本地仓库的代码推送到远程仓库
git remote add origin url (在本地记录远程仓库的地址)
git push origin master
- 4). 如果本地代码有修改, 要提交到本地仓库, 推送到仓库
git add .
git commit -m "xxx"
git push origin master

git config --global credential.helper store (记住用户和密码)

- 5). 如果远程代码有修改, 要拉取到本地仓库
git pull origin master

- 6). 将远程仓库的代码clone到本地(生成仓库)
git clone url

- 分支操作

1). 创建本地分支, 并推送到远程
git checkout -b dev
git push origin origin dev
2). 拉取远程新分支到本地
git pull  (如果分支是在clone后创建的才需要执行)
git checkout -b dev origin/dev
3). 本地dev分支代码修改
git add .
git commit -m "xxx"
git push origin dev
4). 将dev分支合并到master
git checkout master
git merge dev

## 关于语法的一些配置

- 1-eslint:-->创建vue.config.js()注意是在项目的根目录下创建-->配置:lintOnSave: false
- 2-@路径提示: jsconfig.json
  
## Header两种路由导航

- 声明式: `<router-link to="/xxx">`
- 编程式: $router.push/replace('/xxx')

## Footer组件: 只在Login/Register时隐藏

- 给Login/Register路由添加meta配置
- 通过v-show控制footer的显示和隐藏

## 路由跳转和传参问题

- 跳转路由的两种基本方式
  - 声明式: `<router-link to="" replace>`
  - 编程式:this.$router.push()/replace()
- 跳转路由携带的参数类型-->params/query
- 携带参数的2种方式
  - 拼接字符串方式:`/search/${this.keyword}?keyword2=${this.keyword.toUpperCase()}`
  - 采用对象的方式:`this.$router.push({name: 'search', params: { keyword: this.keyword },query: { keyword2: this.keyword.toUpperCase() }})`
  - 注意点:一旦指定带:号的路径, 必须指定name属性来标识当前路由
    - params只能与name组合使用
- query可以与name或者path组合使用

## 面试题(单独积累)

# day02

## 使用postman测试接口

- 1. 启动 ===> 选择登陆==> cancel ===> 进入主界面
- 2. 输入url/参数进行请求测试
- 3. 注意post请求体参数需要指定为json格式
- 4. 保存测试接口 ==> 后面可以反复使用.

## ajax

- 使用前需要下载:npm install -S axios nprogress
- axios二次封装
  - 本身是是原生ajax(Xhr)的封装
  - 二次封装的要求:
    - 1- 配置通用的基础路径和超时:
      - axios.create({baseURL, timeout})
    - 2- 显示请求进度条显示:
      - 准备发请求前显示, 在请求拦截器中执行NProgress.start()
隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()
    - 3. 成功返回的数据不再是response, 而直接是响应体数据response.data
      - 响应拦截器成功的回调中: return response.data
    - 4.统一处理请求错误, 具体请求也可以选择处理或不处理
      - 在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)
  - 测试调用接口请求参数出现404错误
    - 解决办法:
      - 配置baseurl
      - 使用代理
        - `vue.config.js中
                devServer: {
                    proxy: { // 配置代理
                    '/api': { // 只处理以/api开头的请求
                        target: 'http://182.92.128.115', // 转发的目标地址
                        changeOrigin: true // 支持跨域
                    }
                }`

## vuex

1.vue和api交互:ispatch触发actions,actions发送以IBU请求如果是成功了,就baseCategoryList/数据,提交给mutations,mutations接收到数据之后,将数据赋值给state.baseCategoryList (传递给内部管理的state而不是将数据传递给用来存放初始数据的值)
2.下载vuex
  **注意:要声明使用插件
3.vuex的多模块编程应用场景:
  当vue需要管理多个数据的时候,每个功能模块需要单独管理,更方便更具有扩展性

## TypeNav 三级列表动态显示

1.在mounted中分发请求数据的action  使用dispatch触发 注意store 要在vue 的实例对象上边去声明,保证所有组件对象都可以通过$store属性得到store对象
2.mapState
 2.1是vuex的一个辅助函数,...mapState([''])的返回值是一个对象,前边的...是将返回的对象进行拆分
 2.2 何时使用mapstate的对象书写?何时使用mapState的数组书写形式
   解:*当计算属性名和当前总的state的对应的属性名不一致的时候
      *当计算属性名和当前总的state的对应的属性名一致的时候 || 是单模块模式的时候采用
3.mapState({categoryList: state => state.home.baseCategoryList}): 映射home子模块的baseCategoryList属性成为categoryList计算属性 计算属性的值有vuex内部调用的额函数 state是总的state //实际上是 通过对象的方式使属性值变成一个函数,传递的参数就是总状态的state值,以此来直接使用.home....

# day03

## 一些常见的问题和解决方式

- 1 优化高频事件触发处理: 利用lodash进行函数节流处理
    问题: mouseenter事件频繁触发会导致分类列表更新卡的现象
    解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

- 2 优化减小打包文件: 对lodash库实现按需引入
    import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
    import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M

- 3 解决快速移出后可能显示第一个分类的子分类列表的bug
    在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
    在这个0.3s之内可能已经移出去了
- 4 优化减少组件对象数量: 使用编程式导航代替声明式导航
    问题: 使用声明式导航跳转Search, 每个分类项都需要渲染一个RouterLink组件对象  ==> 显示缓慢
    解决: 使用编程式路由导航, 不用创建多个Routerlink组件对象 ===> 显示更快

- 5 优化事件处理效率: 利用事件委托
    问题: 每个分类都绑定了点击监听, 监听回调函数的数量就会非常多  ==> 效率不太高
    解决: 使用事件委托, 从n个点击监听变为1个点击监听 ==> 效率高些
    问题: 需要在点击回调中得到相应的分类数据?  ===> 利用标签的data自定义属性

- 6利用标签data自定义属性携带动态数据
    在标签中指定自定义属性: `<a data-categoryName="abc" data-category1Id="3">`
    在事件回调函数中读取自定义属性数据: const {categoryname, category1id} = aEle.dataset

- 7 控制一级列表的显示与隐藏
    标识状态数据: isShowFirst
    在离开时: 如果当前不是首页隐藏 isShowFirst = false
    在进入时: 显示一级列表 isShowFirst = true

- 8 一级列表显示隐藏的过渡效果
    用`<trasition name="xxx">`包含显示隐藏的标签
    在特定类名下指定过渡样式
    在特定类名下指定隐藏时样式
- 9 优化请求执行的位置, 减少请求次数
    问题: 在首页与搜索页进行路由跳转时, 总会重新请求分类列表    没有必要, 只要一次就可以了
    原因: 首页和搜索页有各自的TypeNav标签对象, 跳转时都是重新创建的, 而我们是在mounted中发请求
    解决: 将dispatch发请求的代码放在App的mounted中执行

- 10 合并分类query参数与搜索的关键字params参数
    问题:
        根据分类搜索时, 会丢失搜索关键字params参数
        根据搜索关键字搜索时, 会丢失分类的query参数
    解决:
        根据分类搜索时, 也携带搜索关键字params参数
        根据搜索关键字搜索时, 也携带上分类的query参数

- 11 Mock接口数据
    问题: 首页只有分类的接口, 其它数据接口还没有写好
    解决: 需要我们前台工程自己在前台mock数据

# day04

- 利用mock接口实现轮播图和floor
在App.vue中测试mock接口的vuex代码
this.$store.dispatch()
- 实现search组件
- 实现静态轮播
1.解决轮播创建爱你一个视频二对象,会影响其他界面的swiper界面.
   原因:类名选择器匹配了所有的swiper界面
   在轮播添加一个id/通过ref使用swiper的根div
2.在listcontainer中分发action请求获取banners数据到state中 --->this.$store.dispatch('gteBanners)
3.将state数据映射为计算属性 `commputed:{...mapstate({banners:staet=>state.home.banners})}`
测试  在控制台vue
home-->index.vue 加mounted dispatxh的代码可以在不同的组件,分发action请求有获取banners数据到state中   (组件的生命周期)
Listcontainers:9-->十一使用v-for遍历banner inbanners
4.解决swiper动态页面的轮播的bug ?
  问题描述:异步获取动态数据+直接在mounted中创建swiper对象,导致没有轮播效果
  原因是:swiper对象创建的时间太早
  解决办法:是要ongoingswiper对象,在列表显示数据之后创建
  不可使用延时定时器:一因为请求获取的时间是不确定的
  使用watch和$
     banners监视变化情况

## 使用mock接口实现动态ListContainer与Floor

### mock接口的vuex编码

    home.js: mutation / action
    App.vue: dipatch()

## 使用swiper实现静态页面轮播

    下载swiper: npm install -S swiper
    引入swiper: js/css
    创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

### 遇到的问题

- 问题1. 一个swiper对象影响多个swiper界面的bug
  - 原因:使用`.container`类名选择器匹配了页面的所有swiper界面,让他们都产生了效果
  - 解决:**使用ref标识swiper的根div--->在列表数据显示之后创建swiper(可查看文档)new Swiper (this.$refs.swiper)

- 问题2. 动态swiper无法轮播的bug
  - 详细描述:异步动态获取数据,开始在mounted中创建swiper对象
  - 原因:swiper创建对象创建的太早
  - 解决:使用swiper对象在列表数据显示之后创建.-->(1.使用延迟定时器,延迟一定的时间***但是请求获取的时间是不确定的)/(2.另外的解决办法:使用watch(banners有数据更新)+$nextTick()-->检查界面也会更新),在回调中创建swiper对象
- 问题3. Carousel组件在Floor组件中使用没效果的bug
- 原因:
  - 给组件标签传入的属性值是空数组/undefined,会创建组件对象,
  - 但是如果是v-for遍历一个空数组/undefined来产生多个标签,但不会创建组件对象
  - watch特点:开始创建不会执行回调,数据更新之后才会执行
  - 最终结果banners对应的carousel组件会显示而floors'对应的组件不会显示
  - 数据变化:
    - banners的数据:[]=>[{img}{img}{img}{img}]
      - 开始是一个空数组,创建Carousel组件对象,默认不会调用watch的回调,所以不会创建swiper对象
      - 而后变成了一个数组(包含4个对象):此时Carousel组件对象会更新数据,调用watch回调,会创建Swiper对象
    - floors的数据:首先是从空数组变成两个对象/楼层数据[]=>[{carouseList:[{img}{img}{img}]},carouseList:[{img}{img}{img}]}]
      - 开始floors组件对象也是一个空数组/undefined 不会创建floor组件,所以内部的carousel组件也不会创建
      - 而后:创建多个组件对象,内部会创建carousel对象,不会执行watch回调(异步回调)
  - 解决:
    - 在mounted中判断数据列表的长度是否>0 如果大于0代表列表数据已经显示了,直接创建swiper==>在watch回调中要判断是否创建了列表数据,有数据创建延时swiper
    - 使用监视的回调函数==>hadle(value){创建延迟swiper之后 使用immediate:true 是用来控制初始显示之前立即调用一次} (如果判断有数据,就会延迟创建swiper)

# day05

## 复习

- 1.自动打开浏览器 open：true 在devser中添加配置
- 2.轮播图自动轮播 --》carouselList中 添加autopaly:true  在props中声明接收一个属性 目的是是floor和banner只有一个组件轮播

## 今日任务

- 搜索页,实现search组件
  - search静态组件,包含searchselect
  - 实现search动态显示动态组件
  - 搜索条件参数准备date.js
  - 根据分类和关键字进行分类搜索(通过传递参数的方式嗖)
  - 根据品牌进行搜索
  - 根据商品属性搜索
  - 根据价格或者排序搜索
  - 自定义分页组件

### 拆分静态组件

- 注意修改图片的路径
  
## search组件动态显示

- api:
  - push 请求方式
  - 定义接口请求函数
- vuex 管理状态数据
- 组件search:dispatch\mapstate\模板

## 搜索参数的理解-->接口文档

- category1Id: '', // 一级分类ID
  category2Id: '', // 二级分类ID
  category3Id: '', // 三级分类ID
  categoryName: '', // 分类名称
  keyword:关键字
  trademark:品牌参数:品牌id:品牌名称(只支持选择一个)
  props:商品属性的数组: ["属性ID:属性值:属性名"]
示例: ["2:6.0～6.24英寸:屏幕尺寸"]
  order:排序方式1:desc//综合排序并且是降序
  pageNo:当前页码默认是第一页

## 搜索条件参数准备date.js

- 分类的条件参数 query 参数:
- 搜索条件参数 params参数keyword关键字
- 注意对象的解构赋值
  - `const obj1={a:1,b:2};const obj2={a:3,c:4} const obj3={...obj1,..obj2,d:5}` ==>obj3={a:3,b:2,c:4,d:5}
  - 在beforemounted中执行同步操作更新data数据
  - 在mounted中执行异步操作,是发送请求
- 问题:当操作关键字的时候,不会发送请求,表示没有再 执行mounted
  - 详细描述:如果当前已经存在search,在通过点击搜索/分类,跳转到search,不会重新搜索==>不会发送请求?
    - 原因:从A跳转到A路由,a路由组件对象不会重新创建,所以就不会重新初始化生命周期
    - 解决:监视$route的变化 ==>(a=>a,$route是重新产生的,是一般监视,如果参数变了,监视的回调函数开始执行)
      - `watch:{'$route'(to,from)}`
      - 通用写法:`watch: {$route(newValue,oldValue) {},},`
      - 根据query和params参数更新options,再请求数据
  - 删除
    - 删除分类条件
      - 重置分类属性数据
      - 重新请求获取数据 
    - 删除搜索条件
      - 重置分类属性数据
      - 重新请求获取数据
    - 但是删除之后地址栏还有相应的标签数据?
    - 原因:删除是没有删除路由数据
    - 解决?重新跳转路由,重新获取请求参数
      - 删除分类:$route.path不带query参数,但是如果有params参数是要携带的 
      - 删除搜索参数:值携带本身的query参数
    - 删除关键字条件,输入框中的关键字没有同步删除?
    - 解决?组件之间的同步问题?
      - 使用全局事件总线.实现search组件和header组件之间通信
      - 1-给vue原型对象指定总线对象
      - 2-在search分发事件==>`this.$bus.$emit("removeKeyword");`,header中绑定事件监听分发事件,来接收数据
      - ==>`mounted () {
            //绑定事件监听来接收消息,更新数据
            this.$bus.$on('removeKeyword',()=>{
           //使用箭头函数,便是当前组件对象
          this.keyword=''
         })`
- 问题:search界面多次重复跳转search
  - 解决办法:就是如果当前页面是search就是用replace方法代替push方法,反之就用push方法
- 问题:点击搜索按钮是,页面会发生跳转,但是地址栏的路径出现问题.
  - 原因:自动提交表单
  - 解决办法==> 使用prevent阻止提交表单

## 根据品牌进行搜索

- 绑定监听:使父组件更新options中的trademark,值是子组件交给父组件(自向父组件传递数据)
- 父组件更新trademark,更新其中的数据,重新获取列表

## 根据商品信息进行搜索'

- 子组件: 绑定监听, 让父组件去更新options中props属性值, 值由子组件来交给父组件 (子向父通信)
- 父组件: 更新props的函数: 向props数组中添加一个新元素, 重新获取商品列表
  - 1). 有可能不需要添加: 如果已经添加过了
  - 2). 一个prop的结构: "属性ID:属性值:属性名'

# day06

## 今日任务

- 1-使用响应式数据对象添加新的属性和删除属性
- 2-排序order
- 3-自定义分页组件
- 4-detail组件

### 响应式数据对象:添加和删除属性的问题

- 什么是响应式数据对象?
  - 是data或state中的对象属性==>内部所有层次的对象都是响应式的,只要更新数据对应的界面就会更新
- 添加新属性?
  - 错误方式==>直接添加 :this.options.trademark = 'xxx'
  - 原因:vue内部没有对应的setter监视,没有对添加属性进行劫持操作导致界面不会更新
  - 解决方式:vm.$set( target, key, value )
            Vue.set( target, key, value )
            为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新
- 删除属性?
  - 错误方式==>直接删除: elete this.options.trademark  
  - 原因:vue内部给响应式数据添加属性,只能监视属性的变化,不能监视属性的删除操作
  - 解决方式:vm.$delete( target, key )
            Vue.delete( target, key )
            删除属性, 同时更新界面

### 排序

- order的数据结构:orderFlag:orderType
- 哪个排序项选中?
- 根据当前order中的orderFlag来确定
- 根据哪个排序项进行什么方式排序?
- 哪个排序项?  根据当前order中的orderFlag来确定
- 什么方式排序?  根据当前order中的orderType确定
- 点击切换排序项和排序方式
- 点击当前排序项: 切换排序方式后进行搜索
- 点击不是当前排序项: 切换排序项, 排序方式为降序

### 自定义分页组件

- 基本步骤?
  - 实现静态组件
  - 设计从外部接受的数据:props
  - 设计从内部包含的数据;
  - 设计基于props和data的计算属性数据
  - 根据props和data以及计算属性进行动态显示数据
  - 更新数据==>更新界面
- 注意点:如果v-for和v-if同时存在的话,for的优先级高于if(面试)
  
### detail静态路由组件

- 步骤
  - 定义静态组件
  - 注册路由
  - 通过`<router-link>`进行跳转
- 注意点:当路由跳转之后,滚定条自动回到起始位置?
  - 解决办法:scrollBehavior (to, from, savedPosition)  {
                   return { x: 0, y: 0 }  // 在跳转路由时, 滚动条自动滚动到x轴和y轴的起始位置
        }

### 优化请求,减少不必要的请求参数

- 知识点:浏览ajax请求提交json请求体参数的时候,如果属性是undefined,不会提交,但是如果是空串就会提交
- 问题:参数值为空串,就没必要提交?
- 解决:提交请求之前,将空串参数数据移除

# day07

## 今日任务

    1). Detail组件动态显示数据
    2). ImageList组件
    3). Zoom组件
    4). 添加到购物车

### 经典错误

- "TypeError: Cannot read property 'category1Name' of undefined"
  - 详细说明:不能再undefined上读取xxx属性
  - 原因:detailInfo初识值是{} {}.xxx就会是undefined  如果undefined.yyy就会报错
  - 解决办法:
    - 1-使用vuex的getters来处理返回对象
    - 2-使用v-if/v-show来解决
      - 但是v-show条件为false时依然会解析,只是样式为display:none
      - v-if条件为false时不会解析 

### imageList组件

- 动态显示数据
- 放大镜的效果
  - 初始化left和top值
  - 取出相关数据event=>offsetX和offsetY
  - 定义mask的宽度:`const maskWidth = this.maskWidth`
  - 计算left==>此时要判断left的临界值
  - 计算top==>判断top的临界值
  - 指定遮罩层的样式坐标
  - 指定右侧大图的样式坐标
  
### 在组件中异步分发action之后,如果知道是成功还是失败,该做怎样的处理?\

- 实现方式?
  - 第一种:利用回调函数的 :`component:dispatch('addToCart', {callback: this.callback})`
    - action: 请求成功或失败后, 调用callback(errorMsg值) // 向组件传递需要显示的errorMsg
    - component: 在callback中, 根据errorMsg参数是否有值来做相应处理
  - 第二种:利用dispatch()的promise返回值
    - async函数执行的返回值是一个promise, 且promise的结果由函数体的结果决定==> 执行dispatch()返回值为promise对象, 它就是async函数返回的promise
    - 方式1:
      action:
      请求操作成功: 返回''
      请求操作失败: 返回errorMsg
      component: 通过dispatch()返回的promise的成功value值来判断成功还是失败了
      方式2:
         action:
        请求操作成功: 返回''
        请求操作失败: throw new Error(errorMsg值)
        component: 通过dispatch()返回的promise是成功的还是失败来判断

# day07

## 今日任务
    1). Detail组件动态显示数据
    2). ImageList组件
    3). Zoom组件
    4). 添加到购物车

## Detail组件动态显示数据
    api: reqProduct()
    vuex: detail.js---state/mutations/actions/getters
    组件: dispatch() / mapState() / mapGetters()

## 错误: "TypeError: Cannot read property 'category1Name' of undefined"
    说明: 不能在undefined上读取xxx属性
    原因: detailInfo初始值是{}, detailInfo.categoryView就是undefined  
          如果执行detailInfo.categoryView.category1Name就会报错了
    解决办法1:
        想办法让detailInfo.categoryView不是undefined ==> 利用vuex的getters来处理返回对象
    解决办法2:
        想办法当detailInfo.categoryView是undefined时, 不解析此块模板, 使用v-if来限制
        说明: v-show不可以(条件为false时, 依然会解析, 只是display为none不显示)
              v-if可以(条件为false时, 不会解析)

## 销售属性的功能
    数据: spuSaleAttrList  ==> isChecked为"1"代表是默认的
    动态显示列表
    点击选中任意一个

## ImageList组件
    动态显示数据
        根据传的imgUrl和bigUrl属性来显示中图和大图
    放大镜的效果:
        布局: 
            左边: 
                <img>: 中图
                event <div>: 用来绑定响应mousemove
                mask <div>: 随着鼠标移动的遮罩   字的尺寸是div的1/4
            右边:
                <div>: 包含大图img, 与左侧尺寸一样
                <img>: 大图, 尺寸是中图的4倍
        事件处理:
            什么事件: mousemove
            给谁绑定: event <div>
            在事件回调函数中做什么?
                移动mask div: 指定其left和top样式: 
                    maskDiv.style.left = left + px
                    maskDiv.style.top = top + px
                移动大图 img: 指定其left和top样式: 
                    bigImg.style.left = -2*top + px
                    bigImg.style.top = -2*top + px
            计算最新的left值和top值
                依赖数据: 事件坐标offsetX和offsetY, mask的宽度maskWidth
                算法: 
                    left = offsetX - maskWidth/2
                    top = offsetY - maskWidth/2
                    限制left和top值只能在[0, maskWidth/2]

## 在组件中分发异步action之后, 如果知道是成功了还是失败了从而做相应处理?
    实现方式1: 利用回调函数数据
        component: dispatch('addToCart', {callback: this.callback}) // 携带回调函数数据
        action: 请求成功或失败后, 调用callback(errorMsg值) // 向组件传递需要显示的errorMsg
        component: 在callback中, 根据errorMsg参数是否有值来做相应处理

    实现方式2: 利用dispatch()的promise返回值
        前置知识:
            async函数执行的返回值是一个promise, 且promise的结果由函数体的结果决定
                throw error ==> 失败了 reason为error
                return 失败的promise  ==> 失败了 reason为函数体返回听promise的reason
                return 成功的promise ==> 成功了, value为函数体返回听promise的value
                return 其它值  ==> 成功了, value为函数体返回的值

            执行dispatch()返回值为promise对象, 它就是async action函数返回的promise
        
        component: dispatch('addToCart', {}) // 不用携带回调函数数据
        方式1:
            action: 
                请求操作成功: 返回''
                请求操作失败: 返回errorMsg
            component: 通过dispatch()返回的promise的成功value值来判断成功还是失败了
        方式2:
            action: 
                请求操作成功: 返回''
                请求操作失败: throw new Error(errorMsg值)
            component: 通过dispatch()返回的promise是成功的还是失败来判断操作是成功的还是失败

# day08

## 今日任务
    1). 添加购物车成功
    2). 购物车数据的CRUD

## 添加购物车成功
    静态路由组件

    跳转路由时携带数据
      params     刷新数据还在
      query    刷新数据还在
      vuex: 在跳转路由前先将数据保存到state中  问题: 刷新就会丢失
      纯浏览器端存储: sessionStorage与localStorage

## sessionStorage与localStorage的使用和区别
    共同点:
        都是只保存在浏览器端
        存储的是文本字符串(如果指定的是对象会自动转换为字符串保存), 
        如果要保存对象/数组, 应该转换为JSON字符串后保存
        语法基本一样:
          sessionStorage.setItem(key, value)/getItem(key)/removeItem(key)
          localStorage.setItem(key, value)/getItem(key)/removeItem(key)
    不同点:
        sessionStorage: 保存在浏览器运行的内存中, 刷新浏览器数据还在, 关闭浏览器会自动清除
        localStorage: 保存在浏览器管理的本地文本中, 无论刷新还关闭浏览器还会存在, 不自动清除

## 购物车路由组件ShopCart

## ShopCart组件--动态列表数据
    api
    vuex
    component

## 用于购物车相关请求的标识数据: 用户临时ID / userTempId
    userTempId的作用:
        在用户未登陆前的身份标识, 用于识别不同的浏览器访问
    userTempId的特点
        它是一个随机唯一的字符串值: 多个客户端之间不相同, 同一个客户端如果产生多次也不同     UUID
        由浏览器端创建, 每次请求都携带给服务器端
        一旦产生, 尽量不删除或修改, 可以一直使用
    userTempId的创建与保存
        使用UUID库来创建: uuidv4()
        保存在哪?: 
            localStorage   ===> 关闭浏览器还存在
            vuex的state中: 从localStorage中读取uuid值保存到state中  ==> 减少从localStorage读取的次数
    userTempId使用
        每次请求都携带上userTempId: 使用axios的请求拦截器


## 改变指定商品的勾选状态
    api: reqCartList()
    vuex: checkCartItem(): 请求失败后抛出包含错误信息的error
    component: change监听回调中dispatch('checkCartItem'), 并根据是否成功做不同处理

## 实现所有购物项商品的全选/全不选功能
    api: 没有一个设置所有购物项选中状态的接口
    vuex: checkAllCartItems()对所有勾选状态需要改变的购物项分别dispatch到checkCartItem()
        action函数中的context对象的结构: {state, getters, commit, dispatch}
    component
        带get和set的计算属性
            显示: 根据cartList中是否所有item都勾选了, 来决定是true/false
            当用户主动改变的checkbox勾选状态: 发请求更新所有购物项的勾选状态为对应的值
        使用一组数组声明式方法: filter()/find()/some()/every()

## 删除指定的一个商品  (作业)

## 删除所有选中的商品 (作业)

## 修改商品的数量
    api: reqAddToCart(skuId, skuNumChange)  
         skuNumChange代表要改变的数量, 如果是正数代表增加, 如果负数代表减少
    vuex:
        addToCart3(context, {skuId, skuNum}): 请求失败后抛出包含异常信息的error对象
    component:
        限制修改后的数量不能小于1, 否则不做修改
        给input输入框绑定change监听, 而不是input监听
        实现输入非数字或小于1的数据都会自动变为原本的数量

# day 09

  ## 今日任务
    1). 注册
    2). 登陆
    3). 自动登陆
    4). 退出登陆 (自己做一下)

## 注册/登陆的路由组件

## 相关的API
    注册
    登陆
    退出登陆

## 注册
    动态显示一次图形验证码, 点击更新图形验证码
    收集用户输入数据: v-model
    进行前台表单验证, 不通过显示提示信息
    发送注册的请求
    如果失败, 提示失败/更新一下图形验证码
    如果成功了, 跳转到登陆的页面

## 登陆
    收集用户输入数据: v-model
    进行前台表单验证, 不通过显示提示信息
    发送登陆的请求
    如果失败, 提示失败
    如果成功了:
        将用户信息(包括token)保存到vuex和localStorage
        跳转到首页  ==> ???后面会优化此功能

## 自动登陆
    方式一: 登陆请求成功后, 将用户的所有信息(用户名/token)保存到localStorage中, 
            初始访问时, 自动读取localStorage中的用户信息来实现自动登陆(不用发请求获取)
    方式二: 登陆请求成功后, 只将用户的token保存到localStorage中
            初始访问时, 自动读取localStorage中的token, 并发送请求根据token获取用户信息(需要发请求获取) 
    注意: 我们的后台没有一个根据token获取用户信息的接口, 只能用方式1

## 退出登陆
    发送退出登陆的请求
    清除用户信息数据(vuex/localStorage)

# day 10

  ## 今日任务
    1). 完成登陆注册的功能
    2). 订单与支付的整体流程相关路由流程
    3). 路由导航守卫
    4). 我的订单列表

    实现: 在Seach界面添加到购物功能 



## 注册/登陆的前台表单校验
    使用vee-validate: npm install -S vee-validate
    根据文档/我们已经实现来完成新的校验功能
    作业: 根据注册的表单校验来实现登陆的表单

## token与userTempId
    userTempId: 
        未登陆用户(浏览器)的标识数据
        浏览器端初始时生成并保存在浏览器端
        每次请求时自动携带: userTempId: uuid字符串值
    teoken: 
        已登陆用户的标识数据
        登陆请求成功时, 服务器端生成并返回给浏览器端保存
        每次请求时(登陆后)自动携带: token: 字符串值(内部包含了用户的id和过期的时间)
    在购物车中的应用的细节
        在未登陆前, 后台是通过userTempId来保存对应的购物车数据
        登陆后, 后台是通过token对应的用户来保存对应的购物车数据
        第一次同时携带userTempId和token获取购物车数据时, 后台会将userTempId对应的数据转移到token对应的用户上, 后面不能再只携带userTempId来获取原来的数据, 必须得携带token来获取数据

## 订单与支付的整体流程相关路由流程
    定义所有的相关一级路由组件并注册, 并通过声明式/编程式路由导航串联起来
    什么时候需要定义二级路由?
          如果在一个大的一级路由界面中有局部界面的切换显示

## 路由导航守卫

`注册全局前置守卫
router.beforeEach((to, from, next) => { 在即将跳转到目标前回调
  console.log('beforeEach()', to, from)
放行
  next()
})
// 注册全局后置守卫
router.afterEach((to, from) => { // 已经跳转到目标路由才调用
  console.log('afterEach()')
})`
    导航守卫是什么?
        vue-router提供的能监控(监视与控制)路由跳转的功能语法
    分类:
        全局守卫
            前置: 监视任意任意路由跳转, 在准备跳转到目标路由时回调
                router.beforeEach((to, from, next) => {})
                to: 目标路由对象
                from: 当前路由对象
                next: 用于控制路由跳转的函数
                    不行执行next(): 中断跳转
                    next(): 放行跳转
                    next(path): 强制跳转到指定路由路径
            后置: 监视任意任意路由跳转, 已经跳转到目标路由才调用
        路由守卫
            前置: 监视跳转到当前路由, 在准备跳转到当前路由时回调
                 beforeEnter: (to, from, next) => { }
        组件守卫
            进入(前置): 监视跳转到当前路由, 在准备跳转到当前路由时回调
                beforeRouteEnter (to, from, next) { },  // 在回调函数中this不是当前组件对象, 还没有创建
            更新
            离开

## 路由守卫相关功能:
    a.只有登陆了, 才能查看交易/支付/个人中心界面
        应该使用全局守卫: 一旦是针对多个路由进行统一处理
    b.只有没有登陆, 才能查看登陆界面
    c.只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面
    d.只能从购物车界面, 才能跳转到交易界面
    e.只能从交易界面, 才能跳转到支付界面
    f.只有从支付界面, 才能跳转到支付成功的界面
        路由守卫
        组件守卫
        完整流程: shopcart ==> trade ==> pay ==> paysuccess

## 在登陆成功后, 自动跳转到前面想访问但因为没登陆而没有看到界面
    1). 在守卫中进行强制跳转到Login时携带redirect参数, 值是想去的目标路径
    2). 登陆成功后, 判断如果有redirect参数, 跳转到redirect的界面, 否则跳转到首页


## 我的订单列表
    定义获取订单分页列表的API函数
    在组件中调用接口请求函数获取指定页码的分页列表数据
    动态显示分页列表与分页界面(Pagination)
        给Pagination绑定的页码改变的监听回调函数可以直接是getOrders
        列表的某些列只显示一行: 通过v-if="index====0"只显示第一行
        如何同时控制多个兄弟标签的显示隐藏: 使用<template v-if="index===0">来包含多个兄弟标签
        列表的某些列要占特定数量的行数: :rowspan="list.length"    

