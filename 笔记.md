## day01vue

### git 的版本控制

- 1). 创建本地仓库(代码在本地仓库中)
创建.gitignore文本, 并配置好
git init
git add .
git commit -m "init app"

- 2). 创建远程仓库
New Repo
指定仓库名
创建

- 3). 将本地仓库的代码推送到远程仓库
git remote add origin url (在本地记录远程仓库的地址)
git push origin master
- 4). 如果本地代码有修改, 要提交到本地仓库, 推送到仓库
git add .
git commit -m "xxx"
git push origin master

git config --global credential.helper store (记住用户和密码)

- 5). 如果远程代码有修改, 要拉取到本地仓库
git pull origin master

- 6). 将远程仓库的代码clone到本地(生成仓库)
git clone url

- 分支操作

1). 创建本地分支, 并推送到远程
git checkout -b dev
git push origin origin dev
2). 拉取远程新分支到本地
git pull  (如果分支是在clone后创建的才需要执行)
git checkout -b dev origin/dev
3). 本地dev分支代码修改
git add .
git commit -m "xxx"
git push origin dev
4). 将dev分支合并到master
git checkout master
git merge dev

## 关于语法的一些配置

- 1-eslint:-->创建vue.config.js()注意是在项目的根目录下创建-->配置:lintOnSave: false
- 2-@路径提示: jsconfig.json
  
## Header两种路由导航

- 声明式: `<router-link to="/xxx">`
- 编程式: $router.push/replace('/xxx')

## Footer组件: 只在Login/Register时隐藏

- 给Login/Register路由添加meta配置
- 通过v-show控制footer的显示和隐藏

## 路由跳转和传参问题

- 跳转路由的两种基本方式
  - 声明式: `<router-link to="" replace>`
  - 编程式:this.$router.push()/replace()
- 跳转路由携带的参数类型-->params/query
- 携带参数的2种方式
  - 拼接字符串方式:`/search/${this.keyword}?keyword2=${this.keyword.toUpperCase()}`
  - 采用对象的方式:`this.$router.push({name: 'search', params: { keyword: this.keyword },query: { keyword2: this.keyword.toUpperCase() }})`
  - 注意点:一旦指定带:号的路径, 必须指定name属性来标识当前路由
    - params只能与name组合使用
- query可以与name或者path组合使用

## 面试题(单独积累)

# day02

## 使用postman测试接口

- 1. 启动 ===> 选择登陆==> cancel ===> 进入主界面
- 2. 输入url/参数进行请求测试
- 3. 注意post请求体参数需要指定为json格式
- 4. 保存测试接口 ==> 后面可以反复使用.

## ajax

- 使用前需要下载:npm install -S axios nprogress
- axios二次封装
  - 本身是是原生ajax(Xhr)的封装
  - 二次封装的要求:
    - 1- 配置通用的基础路径和超时:
      - axios.create({baseURL, timeout})
    - 2- 显示请求进度条显示:
      - 准备发请求前显示, 在请求拦截器中执行NProgress.start()
隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()
    - 3. 成功返回的数据不再是response, 而直接是响应体数据response.data
      - 响应拦截器成功的回调中: return response.data
    - 4.统一处理请求错误, 具体请求也可以选择处理或不处理
      - 在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)
  - 测试调用接口请求参数出现404错误
    - 解决办法:
      - 配置baseurl
      - 使用代理
        - `vue.config.js中
                devServer: {
                    proxy: { // 配置代理
                    '/api': { // 只处理以/api开头的请求
                        target: 'http://182.92.128.115', // 转发的目标地址
                        changeOrigin: true // 支持跨域
                    }
                }`

## vuex

1.vue和api交互:ispatch触发actions,actions发送以IBU请求如果是成功了,就baseCategoryList/数据,提交给mutations,mutations接收到数据之后,将数据赋值给state.baseCategoryList (传递给内部管理的state而不是将数据传递给用来存放初始数据的值)
2.下载vuex
  **注意:要声明使用插件
3.vuex的多模块编程应用场景:
  当vue需要管理多个数据的时候,每个功能模块需要单独管理,更方便更具有扩展性

## TypeNav 三级列表动态显示

1.在mounted中分发请求数据的action  使用dispatch触发 注意store 要在vue 的实例对象上边去声明,保证所有组件对象都可以通过$store属性得到store对象
2.mapState
 2.1是vuex的一个辅助函数,...mapState([''])的返回值是一个对象,前边的...是将返回的对象进行拆分
 2.2 何时使用mapstate的对象书写?何时使用mapState的数组书写形式
   解:*当计算属性名和当前总的state的对应的属性名不一致的时候
      *当计算属性名和当前总的state的对应的属性名一致的时候 || 是单模块模式的时候采用
3.mapState({categoryList: state => state.home.baseCategoryList}): 映射home子模块的baseCategoryList属性成为categoryList计算属性 计算属性的值有vuex内部调用的额函数 state是总的state //实际上是 通过对象的方式使属性值变成一个函数,传递的参数就是总状态的state值,以此来直接使用.home....

## day 04

### 一些常见的问题和解决方式

- 1 优化高频事件触发处理: 利用lodash进行函数节流处理
    问题: mouseenter事件频繁触发会导致分类列表更新卡的现象
    解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

- 2 优化减小打包文件: 对lodash库实现按需引入
    import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
    import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M

- 3 解决快速移出后可能显示第一个分类的子分类列表的bug
    在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
    在这个0.3s之内可能已经移出去了
- 4 优化减少组件对象数量: 使用编程式导航代替声明式导航
    问题: 使用声明式导航跳转Search, 每个分类项都需要渲染一个RouterLink组件对象  ==> 显示缓慢
    解决: 使用编程式路由导航, 不用创建多个Routerlink组件对象 ===> 显示更快

- 5 优化事件处理效率: 利用事件委托
    问题: 每个分类都绑定了点击监听, 监听回调函数的数量就会非常多  ==> 效率不太高
    解决: 使用事件委托, 从n个点击监听变为1个点击监听 ==> 效率高些
    问题: 需要在点击回调中得到相应的分类数据?  ===> 利用标签的data自定义属性

- 6利用标签data自定义属性携带动态数据
    在标签中指定自定义属性: `<a data-categoryName="abc" data-category1Id="3">`
    在事件回调函数中读取自定义属性数据: const {categoryname, category1id} = aEle.dataset

- 7 控制一级列表的显示与隐藏
    标识状态数据: isShowFirst
    在离开时: 如果当前不是首页隐藏 isShowFirst = false
    在进入时: 显示一级列表 isShowFirst = true

- 8 一级列表显示隐藏的过渡效果
    用`<trasition name="xxx">`包含显示隐藏的标签
    在特定类名下指定过渡样式
    在特定类名下指定隐藏时样式
- 9 优化请求执行的位置, 减少请求次数
    问题: 在首页与搜索页进行路由跳转时, 总会重新请求分类列表    没有必要, 只要一次就可以了
    原因: 首页和搜索页有各自的TypeNav标签对象, 跳转时都是重新创建的, 而我们是在mounted中发请求
    解决: 将dispatch发请求的代码放在App的mounted中执行

- 10 合并分类query参数与搜索的关键字params参数
    问题:
        根据分类搜索时, 会丢失搜索关键字params参数
        根据搜索关键字搜索时, 会丢失分类的query参数
    解决:
        根据分类搜索时, 也携带搜索关键字params参数
        根据搜索关键字搜索时, 也携带上分类的query参数

- 11 Mock接口数据
    问题: 首页只有分类的接口, 其它数据接口还没有写好
    解决: 需要我们前台工程自己在前台mock数据

## day04

- 利用mock接口实现轮播图和floor
在App.vue中测试mock接口的vuex代码
this.$store.dispatch()
- 实现search组件
- 实现静态轮播
1.解决轮播创建爱你一个视频二对象,会影响其他界面的swiper界面.
   原因:类名选择器匹配了所有的swiper界面
   在轮播添加一个id/通过ref使用swiper的根div
2.在listcontainer中分发action请求获取banners数据到state中 --->this.$store.dispatch('gteBanners)
3.将state数据映射为计算属性 `commputed:{...mapstate({banners:staet=>state.home.banners})}`
测试  在控制台vue
home-->index.vue 加mounted dispatxh的代码可以在不同的组件,分发action请求有获取banners数据到state中   (组件的生命周期)
Listcontainers:9-->十一使用v-for遍历banner inbanners
4.解决swiper动态页面的轮播的bug ?
  问题描述:异步获取动态数据+直接在mounted中创建swiper对象,导致没有轮播效果
  原因是:swiper对象创建的时间太早
  解决办法:是要ongoingswiper对象,在列表显示数据之后创建
  不可使用延时定时器:一因为请求获取的时间是不确定的
  使用watch和$
     banners监视变化情况

### 使用mock接口实现动态ListContainer与Floor

#### mock接口的vuex编码

    home.js: mutation / action
    App.vue: dipatch()

#### 使用swiper实现静态页面轮播

    下载swiper: npm install -S swiper
    引入swiper: js/css
    创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

#### 遇到的问题

- 问题1. 一个swiper对象影响多个swiper界面的bug
  - 原因:使用`.container`类名选择器匹配了页面的所有swiper界面,让他们都产生了效果
  - 解决:**使用ref标识swiper的根div--->在列表数据显示之后创建swiper(可查看文档)new Swiper (this.$refs.swiper)

- 问题2. 动态swiper无法轮播的bug
  - 详细描述:异步动态获取数据,开始在mounted中创建swiper对象
  - 原因:swiper创建对象创建的太早
  - 解决:使用swiper对象在列表数据显示之后创建.-->(1.使用延迟定时器,延迟一定的时间***但是请求获取的时间是不确定的)/(2.另外的解决办法:使用watch(banners有数据更新)+$nextTick()-->检查界面也会更新),在回调中创建swiper对象
- 问题3. Carousel组件在Floor组件中使用没效果的bug
- 原因:
  - 给组件标签传入的属性值是空数组/undefined,会创建组件对象,
  - 但是如果是v-for遍历一个空数组/undefined来产生多个标签,但不会创建组件对象
  - watch特点:开始创建不会执行回调,数据更新之后才会执行
  - 最终结果banners对应的carousel组件会显示而floors'对应的组件不会显示
  - 数据变化:
    - banners的数据:[]=>[{img}{img}{img}{img}]
      - 开始是一个空数组,创建Carousel组件对象,默认不会调用watch的回调,所以不会创建swiper对象
      - 而后变成了一个数组(包含4个对象):此时Carousel组件对象会更新数据,调用watch回调,会创建Swiper对象
    - floors的数据:首先是从空数组变成两个对象/楼层数据[]=>[{carouseList:[{img}{img}{img}]},carouseList:[{img}{img}{img}]}]
      - 开始floors组件对象也是一个空数组/undefined 不会创建floor组件,所以内部的carousel组件也不会创建
      - 而后:创建多个组件对象,内部会创建carousel对象,不会执行watch回调(异步回调)
  - 解决:
    - 在mounted中判断数据列表的长度是否>0 如果大于0代表列表数据已经显示了,直接创建swiper==>在watch回调中要判断是否创建了列表数据,有数据创建延时swiper
    - 使用监视的回调函数==>hadle(value){创建延迟swiper之后 使用immediate:true 是用来控制初始显示之前立即调用一次} (如果判断有数据,就会延迟创建swiper)

## day 05

### 复习
- 1.自动打开浏览器 open：true 在devser中添加配置
- 2.轮播图自动轮播 --》carouselList中 添加autopaly:true  在props中声明接收一个属性 目的是是floor和banner只有一个组件轮播

### 今日任务

- 搜索页,实现search组件
  - search静态组件,包含searchselect
  - 实现search动态显示动态组件 
  - 搜索条件参数准备date.js
  - 根据分类和关键字进行分类搜索(通过传递参数的方式嗖)
  - 根据品牌进行搜索
  - 根据商品属性搜索
  - 根据价格或者排序搜索
  - 自定义分页组件

#### 拆分静态组件

- 注意修改图片的路径
  
### search组件动态显示

- api:
  - push 请求方式 
  - 定义接口请求函数
- vuex 管理状态数据
- 组件search:dispatch\mapstate\模板

### 搜索参数的理解-->接口文档

- category1Id: '', // 一级分类ID
  category2Id: '', // 二级分类ID
  category3Id: '', // 三级分类ID
  categoryName: '', // 分类名称
  keyword:关键字
  trademark:品牌参数:品牌id:品牌名称(只支持选择一个)
  props:商品属性的数组: ["属性ID:属性值:属性名"]
示例: ["2:6.0～6.24英寸:屏幕尺寸"]
  order:排序方式1:desc//综合排序并且是降序
  pageNo:当前页码默认是第一页

###  搜索条件参数准备date.js

- 分类的条件参数 query 参数:
- 搜索条件参数 params参数keyword关键字
- 注意对象的解构赋值
  - `const obj1={a:1,b:2};const obj2={a:3,c:4} const obj3={...obj1,..obj2,d:5}` ==>obj3={a:3,b:2,c:4,d:5}
  - 在beforemounted中执行同步操作更新data数据
  - 在mounted中执行异步操作,是发送请求
  - 但是出现一个问题:当操作关键字的时候,不会发送请求,表示没有再 执行mounted
    - 详细描述:如果当前已经存在search,在通过点击搜索/分类,跳转到search,不会重新搜索==>不会发送请求?
    - 原因:从A跳转到A路由,a路由组件对象不会重新创建,所以就不会重新初始化生命周期
    - 解决:监视$route的变化 ==>(a=>a,$route是重新产生的,是一般监视,如果参数变了,监视的回调函数开始执行)
      - `watch:{'$route'(to,from)}`
      - 通用写法:`watch: {$route(newValue,oldValue) {},},`
      - 根据query和params参数更新options,再请求数据